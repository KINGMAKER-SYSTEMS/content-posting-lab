<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Caption Burner</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<style>
  /* Font faces are generated dynamically from /api/fonts */

  :root {
    --bg: #0a0a0f;
    --surface: #14141f;
    --surface2: #1a1a2a;
    --border: #2a2a3a;
    --accent: #6c5ce7;
    --accent-hover: #7c6df7;
    --accent-glow: rgba(108,92,231,0.25);
    --text: #e8e8f0;
    --text-dim: #8888a0;
    --success: #00d68f;
    --error: #ff6b6b;
    --warning: #ffc048;
    --radius: 12px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
  }

  .layout {
    display: grid;
    grid-template-columns: 340px 1fr;
    min-height: 100vh;
  }

  /* ─── Sidebar ─── */
  .sidebar {
    border-right: 1px solid var(--border);
    padding: 1.5rem;
    overflow-y: auto;
    height: 100vh;
    position: sticky;
    top: 0;
    display: flex;
    flex-direction: column;
  }

  h1 {
    font-size: 1.4rem;
    font-weight: 700;
    margin-bottom: 0.2rem;
    background: linear-gradient(135deg, var(--accent), #a29bfe);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  .subtitle { color: var(--text-dim); margin-bottom: 1.5rem; font-size: 0.8rem; }

  label {
    display: block;
    font-size: 0.72rem;
    font-weight: 600;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 0.3rem;
  }

  select, input[type="number"], textarea {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    padding: 0.55rem 0.7rem;
    font-size: 0.85rem;
    font-family: inherit;
    margin-bottom: 0.9rem;
  }
  select:focus, input:focus, textarea:focus { outline: none; border-color: var(--accent); }
  textarea { resize: vertical; min-height: 80px; line-height: 1.5; }

  .row { display: flex; gap: 0.7rem; }
  .row > * { flex: 1; }

  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    background: var(--accent);
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 0.7rem 1.5rem;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    width: 100%;
    transition: background 0.2s;
    margin-top: 0.3rem;
  }
  .btn:hover { background: var(--accent-hover); }
  .btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .btn-sm { padding: 0.4rem 0.8rem; font-size: 0.8rem; width: auto; margin-top: 0; }
  .btn-outline { background: transparent; border: 1px solid var(--accent); color: var(--accent); }
  .btn-outline:hover { background: rgba(108,92,231,0.1); }
  .btn-success { background: var(--success); color: #0a0a0f; }
  .btn-success:hover { background: #00e69a; }

  .section-label {
    font-size: 0.72rem;
    font-weight: 600;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding-top: 0.5rem;
    border-top: 1px solid var(--border);
    margin-bottom: 0.5rem;
    margin-top: 0.3rem;
  }

  .chip-row { display: flex; gap: 0.4rem; flex-wrap: wrap; margin-bottom: 0.9rem; }
  .chip {
    padding: 0.3rem 0.7rem;
    border-radius: 6px;
    font-size: 0.78rem;
    font-weight: 600;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.15s;
  }
  .chip.active { border-color: var(--accent); background: rgba(108,92,231,0.15); color: var(--text); }

  .stat-row {
    display: flex;
    justify-content: space-between;
    font-size: 0.8rem;
    color: var(--text-dim);
    margin-bottom: 0.3rem;
  }
  .stat-row strong { color: var(--text); }

  /* ─── Progress ─── */
  .progress-track {
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
    display: none;
    margin-top: 0.6rem;
  }
  .progress-track.active { display: block; }
  .progress-fill {
    height: 100%;
    background: var(--accent);
    border-radius: 2px;
    transition: width 0.4s ease;
    width: 0%;
  }
  .progress-fill.complete { background: var(--success); }
  .progress-label {
    font-size: 0.75rem;
    color: var(--text-dim);
    text-align: center;
    margin-top: 0.3rem;
    display: none;
  }
  .progress-label.active { display: block; }

  /* ─── Main panel ─── */
  .main-panel {
    padding: 1.5rem;
    overflow-y: auto;
    max-height: 100vh;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .panel-title { font-size: 1.2rem; font-weight: 700; }
  .count-badge {
    font-size: 0.78rem;
    background: var(--surface2);
    padding: 0.2rem 0.6rem;
    border-radius: 4px;
    color: var(--text-dim);
  }

  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 60vh;
    color: var(--text-dim);
    text-align: center;
  }
  .empty-state .icon { font-size: 3rem; opacity: 0.3; margin-bottom: 0.6rem; }

  /* ─── Video cards ─── */
  .video-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 1rem;
  }

  .video-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    overflow: hidden;
    transition: border-color 0.2s;
    position: relative;
  }
  .video-card:hover { border-color: var(--accent); }
  .video-card.burned { border-color: var(--success); }
  .video-card.error { border-color: var(--error); }
  .video-card.selected { border-color: var(--accent); box-shadow: 0 0 12px var(--accent-glow); }

  .video-card .video-wrap {
    position: relative;
    background: #000;
    aspect-ratio: 9/16;
    overflow: hidden;
    cursor: default;
  }
  .video-card video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    pointer-events: none;
  }

  /* ─── Draggable text layer ─── */
  .text-layer {
    position: absolute;
    z-index: 10;
    cursor: grab;
    user-select: none;
    touch-action: none;
    max-width: 80%;
    text-align: center;
    transform: translate(-50%, -50%);
  }
  .text-layer.dragging { cursor: grabbing; }
  .text-layer.selected-layer {
    outline: 2px dashed var(--accent);
    outline-offset: 6px;
    border-radius: 4px;
  }
  .text-layer span {
    font-family: inherit;
    font-weight: 700;
    color: white;
    -webkit-text-stroke: 1.5px black;
    paint-order: stroke fill;
    line-height: 1.2;
    word-wrap: break-word;
    display: inline-block;
  }

  .text-layer textarea {
    background: transparent;
    border: none;
    outline: none;
    resize: none;
    overflow: hidden;
    font-family: inherit;
    font-weight: 700;
    color: white;
    -webkit-text-stroke: 1.5px black;
    paint-order: stroke fill;
    line-height: 1.2;
    text-align: center;
    width: 100%;
    min-height: 1.4em;
    cursor: text;
  }

  /* Snap guides */
  .snap-guide-h, .snap-guide-v {
    position: absolute;
    z-index: 20;
    pointer-events: none;
    display: none;
  }
  .snap-guide-h {
    left: 0; right: 0;
    top: 50%;
    height: 1px;
    background: var(--accent);
    opacity: 0.7;
  }
  .snap-guide-v {
    top: 0; bottom: 0;
    left: 50%;
    width: 1px;
    background: var(--accent);
    opacity: 0.7;
  }

  .video-card .card-footer {
    padding: 0.5rem 0.6rem;
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
  }
  .video-card .card-footer .file-label {
    font-size: 0.68rem;
    color: var(--text-dim);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .card-caption-edit {
    font-size: 0.82rem;
    min-height: 44px;
    padding: 0.4rem;
    border-radius: 6px;
    margin-bottom: 0;
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    width: 100%;
    font-family: inherit;
    resize: vertical;
    line-height: 1.5;
  }
  .card-caption-edit:focus { outline: none; border-color: var(--accent); }

  .card-controls {
    display: none;
    padding: 0.4rem 0.6rem 0.5rem;
    border-top: 1px solid var(--border);
    gap: 0.4rem;
    flex-wrap: wrap;
    align-items: center;
  }
  .video-card.selected .card-controls { display: flex; }
  .card-controls label { margin-bottom: 0; font-size: 0.65rem; }
  .card-controls select, .card-controls input[type="number"] {
    margin-bottom: 0;
    padding: 0.3rem 0.4rem;
    font-size: 0.75rem;
    width: auto;
    min-width: 60px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
  }

  .burn-badge {
    position: absolute;
    top: 8px; right: 8px;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    font-size: 0.7rem;
    font-weight: 700;
    z-index: 25;
  }
  .burn-badge.done { background: var(--success); color: #0a0a0f; }
  .burn-badge.fail { background: var(--error); color: white; }

  .export-bar {
    display: none;
    align-items: center;
    justify-content: space-between;
    padding: 0.7rem 1rem;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
  }
  .export-bar.active { display: flex; }
  .export-bar .info { font-size: 0.82rem; color: var(--text-dim); }
  .export-bar .actions { display: flex; gap: 0.5rem; }

  /* ─── Past Batches ─── */
  .batch-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.45rem 0.65rem;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 0.78rem;
    cursor: pointer;
    transition: border-color 0.15s;
  }
  .batch-item:hover { border-color: var(--accent); }
  .batch-item .batch-info { color: var(--text-dim); }
  .batch-item .batch-info strong { color: var(--text); }
  .batch-item .batch-dl {
    background: var(--accent);
    color: white;
    border: none;
    padding: 0.2rem 0.5rem;
    border-radius: 5px;
    font-size: 0.72rem;
    cursor: pointer;
  }
  .batch-item .batch-dl:hover { background: var(--accent-hover); }

  /* ─── Color Correction Sliders ─── */
  .cc-slider-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.35rem;
  }
  .cc-slider-row .cc-label {
    font-size: 0.72rem;
    color: var(--text-dim);
    min-width: 72px;
    text-transform: none;
    letter-spacing: 0;
    font-weight: 500;
    margin-bottom: 0;
  }
  .cc-slider-row input[type="range"] {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
    margin: 0;
    padding: 0;
    border: none;
  }
  .cc-slider-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 2px solid var(--bg);
  }
  .cc-slider-row input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 2px solid var(--bg);
  }
  .cc-slider-row .cc-value {
    font-size: 0.7rem;
    color: var(--text);
    min-width: 28px;
    text-align: right;
    font-variant-numeric: tabular-nums;
  }
  .cc-reset-btn {
    padding: 0.25rem 0.6rem;
    font-size: 0.68rem;
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 5px;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.15s;
    margin-top: 0.2rem;
    margin-bottom: 0.5rem;
  }
  .cc-reset-btn:hover { border-color: var(--accent); color: var(--text); }

  .apply-all-btn {
    padding: 0.35rem 0.7rem;
    font-size: 0.72rem;
    background: rgba(108,92,231,0.15);
    border: 1px solid var(--accent);
    border-radius: 6px;
    color: var(--accent);
    cursor: pointer;
    transition: all 0.15s;
    margin-top: 0.5rem;
  }
  .apply-all-btn:hover { background: rgba(108,92,231,0.25); }

  @media (max-width: 800px) {
    .layout { grid-template-columns: 1fr; }
    .sidebar { position: static; max-height: none; border-right: none; border-bottom: 1px solid var(--border); }
    .main-panel { max-height: none; }
    .video-grid { grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); }
  }
</style>
</head>
<body>

<div class="layout">
  <div class="sidebar">
    <h1>Caption Burner</h1>
    <p class="subtitle">Pair videos with captions, drag to position, burn & download</p>

    <label>Video Folder</label>
    <select id="folderSelect"><option value="">Loading...</option></select>

    <label>Caption Source</label>
    <select id="captionSelect">
      <option value="__paste">Paste manually</option>
    </select>

    <div id="pasteWrap" style="display:none">
      <label>Captions (one per line)</label>
      <textarea id="pasteArea" placeholder="First caption&#10;Second caption&#10;Third caption"></textarea>
    </div>

    <div class="section-label">Style Defaults</div>

    <div class="row">
      <div>
        <label>Font</label>
        <select id="fontSelect"><option value="">Loading...</option></select>
      </div>
      <div>
        <label>Size</label>
        <input type="number" id="fontSize" value="32" min="8" max="120" />
      </div>
    </div>

    <label>Quick Position</label>
    <div class="chip-row" id="posChips">
      <span class="chip" data-pos="top">Top</span>
      <span class="chip active" data-pos="center">Center</span>
      <span class="chip" data-pos="bottom">Bottom</span>
    </div>

    <div class="section-label">Color Correction</div>
    <div id="ccSliders">
      <div class="cc-slider-row">
        <span class="cc-label">Brightness</span>
        <input type="range" id="ccBrightness" min="-100" max="100" value="0" />
        <span class="cc-value" id="ccBrightnessVal">0</span>
      </div>
      <div class="cc-slider-row">
        <span class="cc-label">Contrast</span>
        <input type="range" id="ccContrast" min="-100" max="100" value="0" />
        <span class="cc-value" id="ccContrastVal">0</span>
      </div>
      <div class="cc-slider-row">
        <span class="cc-label">Saturation</span>
        <input type="range" id="ccSaturation" min="-100" max="100" value="0" />
        <span class="cc-value" id="ccSaturationVal">0</span>
      </div>
      <div class="cc-slider-row">
        <span class="cc-label">Sharpness</span>
        <input type="range" id="ccSharpness" min="0" max="100" value="0" />
        <span class="cc-value" id="ccSharpnessVal">0</span>
      </div>
      <div class="cc-slider-row">
        <span class="cc-label">Shadow</span>
        <input type="range" id="ccShadow" min="-100" max="100" value="0" />
        <span class="cc-value" id="ccShadowVal">0</span>
      </div>
      <div class="cc-slider-row">
        <span class="cc-label">Temperature</span>
        <input type="range" id="ccTemperature" min="-100" max="100" value="0" />
        <span class="cc-value" id="ccTemperatureVal">0</span>
      </div>
      <div class="cc-slider-row">
        <span class="cc-label">Tint</span>
        <input type="range" id="ccTint" min="-100" max="100" value="0" />
        <span class="cc-value" id="ccTintVal">0</span>
      </div>
      <div class="cc-slider-row">
        <span class="cc-label">Fade</span>
        <input type="range" id="ccFade" min="0" max="100" value="0" />
        <span class="cc-value" id="ccFadeVal">0</span>
      </div>
    </div>
    <button class="cc-reset-btn" id="ccResetBtn">Reset All</button>

    <div class="section-label" style="margin-top:1.2rem">PAST BATCHES</div>
    <div id="batchList" style="display:flex;flex-direction:column;gap:0.4rem;max-height:160px;overflow-y:auto;flex-shrink:0"></div>

    <div class="stat-row">
      <span>Videos</span>
      <strong id="videoCount">0</strong>
    </div>
    <div class="stat-row">
      <span>Captions</span>
      <strong id="captionCount">0</strong>
    </div>

    <button class="btn" id="alignBtn">Align & Preview</button>

    <button class="apply-all-btn" id="applyAllBtn" style="display:none">Apply Current Style to All</button>

    <div class="progress-track" id="progressTrack">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="progress-label" id="progressLabel"></div>

    <button class="btn btn-success" id="burnBtn" style="display:none">Burn All</button>

    <div id="downloadSection" style="display:none">
      <button class="btn btn-outline" id="downloadAllBtn">Download All Burned</button>
    </div>

  </div>

  <div class="main-panel">
    <div id="emptyState" class="empty-state">
      <div class="icon">&#128293;</div>
      <p>Pick a video folder and caption source,<br/>then hit Align & Preview.</p>
    </div>

    <div id="gallery" style="display:none">
      <div class="panel-header">
        <span class="panel-title">Paired Clips</span>
        <span class="count-badge" id="pairCount">0 pairs</span>
      </div>

      <div class="export-bar" id="exportBar">
        <span class="info" id="exportInfo">0 burned</span>
        <div class="actions">
          <button class="btn btn-sm btn-success" id="dlBurnedBtn">Download All</button>
        </div>
      </div>

      <div class="video-grid" id="videoGrid"></div>
    </div>
  </div>
</div>

<script>
let allVideos = [];
let captionSources = [];
let availableFonts = [];
let pairs = [];
let burning = false;
let selectedIndex = -1;

const $ = id => document.getElementById(id);

// Map font filename to a unique CSS family name for preview
function fontFamilyName(file) {
  return 'tt-' + file.replace('.ttf', '').replace('.otf', '');
}

const folderSelect = $('folderSelect');
const captionSelect = $('captionSelect');
const pasteWrap = $('pasteWrap');
const pasteArea = $('pasteArea');
const fontSelect = $('fontSelect');
const fontSizeInput = $('fontSize');
const posChips = $('posChips');
const videoCount = $('videoCount');
const captionCount = $('captionCount');
const alignBtn = $('alignBtn');
const burnBtn = $('burnBtn');
const progressTrack = $('progressTrack');
const progressFill = $('progressFill');
const progressLabel = $('progressLabel');
const emptyState = $('emptyState');
const gallery = $('gallery');
const videoGrid = $('videoGrid');
const pairCount = $('pairCount');
const exportBar = $('exportBar');
const exportInfo = $('exportInfo');
const dlBurnedBtn = $('dlBurnedBtn');
const downloadSection = $('downloadSection');
const downloadAllBtn = $('downloadAllBtn');
const applyAllBtn = $('applyAllBtn');
const ccResetBtn = $('ccResetBtn');

// ── Color Correction ──
const CC_SLIDERS = ['Brightness','Contrast','Saturation','Sharpness','Shadow','Temperature','Tint','Fade'];

// Wire slider value displays + live sync to pairs + CSS preview
function syncColorCorrectionToPairs() {
  const cc = getColorCorrection();
  pairs.forEach(p => { p.colorCorrection = cc; });
  applyCSSFilterPreview();
}

function applyCSSFilterPreview() {
  const b = parseInt($('ccBrightness').value) || 0;
  const c = parseInt($('ccContrast').value) || 0;
  const s = parseInt($('ccSaturation').value) || 0;
  const sh = parseInt($('ccSharpness').value) || 0;
  const sd = parseInt($('ccShadow').value) || 0;
  const t = parseInt($('ccTemperature').value) || 0;
  const ti = parseInt($('ccTint').value) || 0;
  const f = parseInt($('ccFade').value) || 0;

  // CSS filter values — these are the source of truth
  let cssBrightness = 1 + b / 100;   // 0 → 2 (multiplier)
  let cssContrast = 1 + c / 100;     // 0 → 2
  let cssSaturate = 1 + s / 100;     // 0 → 2

  // Fade compound
  if (f > 0) {
    const fade = f / 100;
    cssBrightness = Math.min(2, cssBrightness + fade * 0.4);
    cssContrast = Math.max(0.2, cssContrast - fade * 0.3);
    cssSaturate = Math.max(0.2, cssSaturate - fade * 0.4);
  }

  // Shadow nudges brightness
  if (sd !== 0) cssBrightness += sd / 400;

  const parts = [];
  if (Math.abs(cssBrightness - 1) > 0.005) parts.push(`brightness(${cssBrightness.toFixed(3)})`);
  if (Math.abs(cssContrast - 1) > 0.005) parts.push(`contrast(${cssContrast.toFixed(3)})`);
  if (Math.abs(cssSaturate - 1) > 0.005) parts.push(`saturate(${cssSaturate.toFixed(3)})`);

  // Temperature: warm = sepia, cool = hue-rotate blue
  if (Math.abs(t) > 1) {
    if (t > 0) parts.push(`sepia(${(t / 200).toFixed(3)})`);
    else parts.push(`hue-rotate(${(t / 5).toFixed(1)}deg)`);
  }
  // Tint: hue-rotate
  if (Math.abs(ti) > 1) parts.push(`hue-rotate(${(ti / 3).toFixed(1)}deg)`);

  const filterStr = parts.length ? parts.join(' ') : 'none';
  videoGrid.querySelectorAll('video').forEach(v => { v.style.filter = filterStr; });
}

CC_SLIDERS.forEach(name => {
  const slider = $('cc' + name);
  const valSpan = $('cc' + name + 'Val');
  slider.addEventListener('input', () => {
    valSpan.textContent = slider.value;
    syncColorCorrectionToPairs();
  });
});

ccResetBtn.addEventListener('click', () => {
  CC_SLIDERS.forEach(name => {
    const slider = $('cc' + name);
    slider.value = 0;
    $('cc' + name + 'Val').textContent = '0';
  });
  syncColorCorrectionToPairs();
});

function getColorCorrection() {
  const b = parseInt($('ccBrightness').value) || 0;
  const c = parseInt($('ccContrast').value) || 0;
  const s = parseInt($('ccSaturation').value) || 0;
  const sh = parseInt($('ccSharpness').value) || 0;
  const sd = parseInt($('ccShadow').value) || 0;
  const t = parseInt($('ccTemperature').value) || 0;
  const ti = parseInt($('ccTint').value) || 0;
  const f = parseInt($('ccFade').value) || 0;

  // All defaults → return null (no overhead)
  if (b === 0 && c === 0 && s === 0 && sh === 0 && sd === 0 && t === 0 && ti === 0 && f === 0) {
    return null;
  }

  // Send raw slider integers — backend maps to ffmpeg to match CSS preview
  return {
    brightness: b,     // -100 → 100
    contrast: c,       // -100 → 100
    saturation: s,     // -100 → 100
    sharpness: sh,     // 0 → 100
    shadow: sd,        // -100 → 100
    temperature: t,    // -100 → 100
    tint: ti,          // -100 → 100
    fade: f,           // 0 → 100
  };
}

// ── Init: scan disk ──
(async () => {
  const [vRes, cRes, fRes] = await Promise.all([
    fetch('/api/videos').then(r => r.json()),
    fetch('/api/captions').then(r => r.json()),
    fetch('/api/fonts').then(r => r.json()),
  ]);
  allVideos = vRes.videos;
  captionSources = cRes.sources;
  availableFonts = fRes.fonts;

  // Folder dropdown
  folderSelect.innerHTML = '';
  const folders = {};
  allVideos.forEach(v => {
    const f = v.folder || '(root)';
    if (!folders[f]) folders[f] = [];
    folders[f].push(v);
  });
  Object.keys(folders).forEach(f => {
    const opt = document.createElement('option');
    opt.value = f;
    // Show short label: last folder part, cleaned up
    const parts = f.split('/');
    const label = parts[parts.length - 1].replace(/_/g, ' ').substring(0, 40);
    opt.textContent = `${label} (${folders[f].length})`;
    opt.title = f;  // full path on hover
    folderSelect.appendChild(opt);
  });
  if (!folderSelect.options.length) {
    folderSelect.innerHTML = '<option value="">No videos in video-output/</option>';
  }

  // Caption dropdown
  captionSelect.innerHTML = '<option value="__paste">Paste manually</option>';
  captionSources.forEach(src => {
    const opt = document.createElement('option');
    opt.value = src.username;
    opt.textContent = `@${src.username} (${src.count} captions)`;
    captionSelect.appendChild(opt);
  });

  // Font dropdown + dynamic @font-face loading
  fontSelect.innerHTML = '';
  const styleEl = document.createElement('style');
  availableFonts.forEach(f => {
    // Each font file gets a unique family name so we can switch in preview
    const family = fontFamilyName(f.file);
    styleEl.textContent += `
      @font-face {
        font-family: '${family}';
        src: url('/fonts/${f.file}') format('truetype');
        font-weight: 700;
        font-style: normal;
      }
    `;
    const opt = document.createElement('option');
    opt.value = f.file;
    opt.textContent = f.name;
    if (f.file.includes('16pt-Bold.')) opt.selected = true;
    fontSelect.appendChild(opt);
  });
  document.head.appendChild(styleEl);

  updateStats();
  loadBatches();
})();

// ── Past Batches ──
const batchList = $('batchList');

async function loadBatches() {
  const res = await fetch('/api/batches').then(r => r.json());
  batchList.innerHTML = '';
  if (!res.batches.length) {
    batchList.innerHTML = '<div style="font-size:0.78rem;color:var(--text-dim)">No batches yet</div>';
    return;
  }
  res.batches.forEach(b => {
    const date = new Date(b.created * 1000);
    const timeStr = date.toLocaleDateString(undefined, { month:'short', day:'numeric' })
      + ' ' + date.toLocaleTimeString(undefined, { hour:'numeric', minute:'2-digit' });
    const el = document.createElement('div');
    el.className = 'batch-item';
    el.innerHTML = `
      <span class="batch-info"><strong>${b.count} clips</strong> · ${timeStr}</span>
      <button class="batch-dl" onclick="event.stopPropagation();const a=document.createElement('a');a.href='/api/burn-zip/${b.id}';a.download='burned_${b.id}.zip';a.click()">ZIP</button>
    `;
    batchList.appendChild(el);
  });
}

// ── Stats ──
folderSelect.addEventListener('change', updateStats);
captionSelect.addEventListener('change', () => {
  pasteWrap.style.display = captionSelect.value === '__paste' ? '' : 'none';
  updateStats();
});
pasteArea.addEventListener('input', updateStats);

// Font change: update all pairs and refresh preview
fontSelect.addEventListener('change', () => {
  const newFont = fontSelect.value;
  pairs.forEach((p, i) => {
    p.fontFile = newFont;
    const layer = videoGrid.children[i]?.querySelector('.text-layer');
    if (layer) layer.style.fontFamily = `'${fontFamilyName(newFont)}', sans-serif`;
  });
});

function updateStats() {
  const folder = folderSelect.value;
  const vids = allVideos.filter(v => (v.folder || '(root)') === folder);
  videoCount.textContent = vids.length;
  captionCount.textContent = getCaptions().length;
}

function getCaptions() {
  if (captionSelect.value === '__paste') {
    return pasteArea.value.split('\n').filter(l => l.trim()).map(l => l.trim());
  }
  const src = captionSources.find(s => s.username === captionSelect.value);
  return src ? src.captions.map(c => c.text) : [];
}

// ── Quick position chips ──
posChips.addEventListener('click', e => {
  const chip = e.target.closest('.chip');
  if (!chip) return;
  posChips.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
  chip.classList.add('active');
  const pos = chip.dataset.pos;
  const yMap = { top: 15, center: 50, bottom: 85 };
  const y = yMap[pos] || 50;
  pairs.forEach(p => { p.x = 50; p.y = y; });
  refreshAllOverlays();
});

// ── Align & Preview ──
alignBtn.addEventListener('click', () => {
  const folder = folderSelect.value;
  if (!folder) return;
  const vids = allVideos.filter(v => (v.folder || '(root)') === folder);
  if (!vids.length) return;

  const captions = getCaptions();
  const defFont = fontSelect.value;
  const defSize = parseInt(fontSizeInput.value) || 32;
  const activePos = posChips.querySelector('.chip.active');
  const yMap = { top: 15, center: 50, bottom: 85 };
  const defY = yMap[activePos?.dataset.pos] || 50;

  const cc = getColorCorrection();
  pairs = vids.map((v, i) => ({
    videoPath: v.path,
    name: v.name,
    caption: captions.length > 0 ? captions[i % captions.length] : '',
    x: 50,
    y: defY,
    fontSize: defSize,
    fontFile: defFont,
    maxWidthPct: 80,
    colorCorrection: cc,
    result: null,
  }));

  renderGrid();
  emptyState.style.display = 'none';
  gallery.style.display = '';
  burnBtn.style.display = '';
  applyAllBtn.style.display = '';
  pairCount.textContent = `${pairs.length} pairs`;
  exportBar.classList.remove('active');
  downloadSection.style.display = 'none';
});

// ── Render grid ──
function renderGrid() {
  videoGrid.innerHTML = '';

  pairs.forEach((pair, i) => {
    const card = document.createElement('div');
    card.className = 'video-card';
    card.dataset.idx = i;

    card.innerHTML = `
      <div class="video-wrap" data-wrap="${i}">
        <video src="/video/${encodeURI(pair.videoPath)}" muted loop playsinline preload="metadata"></video>
        <div class="snap-guide-h"></div>
        <div class="snap-guide-v"></div>
        <div class="text-layer" data-layer="${i}"
             style="left:${pair.x}%;top:${pair.y}%;font-family:'${fontFamilyName(pair.fontFile)}',sans-serif">
          <span>${esc(pair.caption)}</span>
        </div>
      </div>
      <div class="card-footer">
        <div class="file-label" title="${pair.name}">${pair.name}</div>
        <textarea class="card-caption-edit" rows="2" data-cap="${i}">${esc(pair.caption)}</textarea>
      </div>
      <div class="card-controls">
        <label>Size</label>
        <input type="number" value="${pair.fontSize}" min="8" max="120" data-fsi="${i}" style="width:60px" />
      </div>
    `;

    // Video hover play + read real resolution for font scaling
    const vid = card.querySelector('video');
    vid.addEventListener('loadedmetadata', () => {
      pair.videoWidth = vid.videoWidth;
      pair.videoHeight = vid.videoHeight;
      updateLayerStyle(i);
    });
    card.addEventListener('mouseenter', () => vid.play().catch(() => {}));
    card.addEventListener('mouseleave', () => { vid.pause(); vid.currentTime = 0; });

    // Select card on click
    card.addEventListener('click', (e) => {
      if (e.target.closest('.text-layer') || e.target.closest('.card-caption-edit') || e.target.closest('.card-controls')) return;
      selectCard(i);
    });

    // Caption textarea edit
    card.querySelector(`[data-cap="${i}"]`).addEventListener('input', e => {
      pair.caption = e.target.value;
      const layerSpan = card.querySelector(`.text-layer span`);
      if (layerSpan) layerSpan.textContent = e.target.value;
    });

    // Font size control
    const fsi = card.querySelector(`[data-fsi="${i}"]`);
    fsi.addEventListener('change', () => {
      pair.fontSize = parseInt(fsi.value) || 32;
      updateLayerStyle(i);
    });

    // Set up dragging on the text layer
    setupDrag(card, i);

    // Double-click text layer to edit inline
    setupInlineEdit(card, i);

    videoGrid.appendChild(card);
  });

  // Apply any active color correction CSS filters to the new video elements
  applyCSSFilterPreview();
}

function selectCard(idx) {
  document.querySelectorAll('.video-card.selected').forEach(c => c.classList.remove('selected'));
  if (selectedIndex === idx) {
    selectedIndex = -1;
    return;
  }
  selectedIndex = idx;
  const card = videoGrid.children[idx];
  if (card) card.classList.add('selected');
}

// Single source of truth for text stroke width (px at full video resolution).
// Used by both the CSS preview (scaled down) and the canvas capture (at full res).
const TEXT_STROKE_PX = 3;

function updateLayerStyle(idx) {
  const pair = pairs[idx];
  const card = videoGrid.children[idx];
  const layer = card?.querySelector('.text-layer');
  const wrap = card?.querySelector('.video-wrap');
  if (!layer || !wrap) return;

  const cardWidth = wrap.offsetWidth;
  const videoWidth = pair.videoWidth || 432;
  const scale = cardWidth / videoWidth;
  const previewFontPx = Math.max(6, Math.round(pair.fontSize * scale));

  layer.style.fontSize = previewFontPx + 'px';
  layer.style.left = pair.x + '%';
  layer.style.top = pair.y + '%';
  layer.style.fontFamily = `'${fontFamilyName(pair.fontFile)}', sans-serif`;
  // Scale stroke proportionally — same base value (TEXT_STROKE_PX) as canvas capture
  const strokePx = Math.max(0.5, TEXT_STROKE_PX * scale);
  layer.querySelector('span').style.webkitTextStroke = strokePx.toFixed(1) + 'px black';
}

function refreshAllOverlays() {
  pairs.forEach((_, i) => updateLayerStyle(i));
}

// ── Drag system (adapted from Shippi TextLayer) ──
function setupDrag(card, idx) {
  const layer = card.querySelector('.text-layer');
  const wrap = card.querySelector('.video-wrap');
  const guideH = card.querySelector('.snap-guide-h');
  const guideV = card.querySelector('.snap-guide-v');
  const SNAP = 3; // snap within 3% of center

  let startX, startY, startLayerX, startLayerY, dragging = false;

  layer.addEventListener('pointerdown', (e) => {
    if (e.target.tagName === 'TEXTAREA') return;
    e.preventDefault();
    e.stopPropagation();
    dragging = true;
    layer.classList.add('dragging');
    layer.classList.add('selected-layer');
    selectCard(idx);

    const rect = wrap.getBoundingClientRect();
    startX = e.clientX;
    startY = e.clientY;
    startLayerX = pairs[idx].x;
    startLayerY = pairs[idx].y;

    const onMove = (me) => {
      if (!dragging) return;
      const dx = me.clientX - startX;
      const dy = me.clientY - startY;
      let newX = startLayerX + (dx / rect.width) * 100;
      let newY = startLayerY + (dy / rect.height) * 100;

      newX = Math.max(5, Math.min(95, newX));
      newY = Math.max(5, Math.min(95, newY));

      // Center snapping
      let snapH = false, snapV = false;
      if (Math.abs(newX - 50) < SNAP) { newX = 50; snapV = true; }
      if (Math.abs(newY - 50) < SNAP) { newY = 50; snapH = true; }

      guideH.style.display = snapH ? 'block' : 'none';
      guideV.style.display = snapV ? 'block' : 'none';

      pairs[idx].x = newX;
      pairs[idx].y = newY;
      layer.style.left = newX + '%';
      layer.style.top = newY + '%';
    };

    const onUp = () => {
      dragging = false;
      layer.classList.remove('dragging');
      guideH.style.display = 'none';
      guideV.style.display = 'none';
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onUp);
    };

    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onUp);
  });
}

// ── Inline text editing (double-click) ──
function setupInlineEdit(card, idx) {
  const layer = card.querySelector('.text-layer');
  let editing = false;

  layer.addEventListener('dblclick', (e) => {
    if (editing) return;
    e.stopPropagation();
    editing = true;

    const span = layer.querySelector('span');
    const ta = document.createElement('textarea');
    ta.value = pairs[idx].caption;
    ta.style.fontSize = span.style?.fontSize || layer.style.fontSize;
    ta.rows = Math.max(1, pairs[idx].caption.split('\n').length);

    span.style.display = 'none';
    layer.appendChild(ta);
    ta.focus();
    ta.select();

    // Auto-resize
    const resize = () => {
      ta.style.height = 'auto';
      ta.style.height = ta.scrollHeight + 'px';
    };
    ta.addEventListener('input', () => {
      pairs[idx].caption = ta.value;
      // Sync with card textarea
      const cardTa = card.querySelector('.card-caption-edit');
      if (cardTa) cardTa.value = ta.value;
      resize();
    });
    resize();

    const finish = () => {
      editing = false;
      span.textContent = pairs[idx].caption;
      span.style.display = '';
      ta.remove();
    };

    ta.addEventListener('blur', finish);
    ta.addEventListener('keydown', (ke) => {
      if (ke.key === 'Escape') { ta.blur(); }
    });
  });
}

// ── Apply style to all ──
applyAllBtn.addEventListener('click', () => {
  const defFont = fontSelect.value;
  const defSize = parseInt(fontSizeInput.value) || 32;
  const activePos = posChips.querySelector('.chip.active');
  const yMap = { top: 15, center: 50, bottom: 85 };
  const defY = yMap[activePos?.dataset.pos] || 50;
  const cc = getColorCorrection();

  pairs.forEach((p, i) => {
    p.fontSize = defSize;
    p.fontFile = defFont;
    p.x = 50;
    p.y = defY;
    p.colorCorrection = cc;
    // Update the per-card size input
    const fsi = videoGrid.children[i]?.querySelector(`[data-fsi="${i}"]`);
    if (fsi) fsi.value = defSize;
  });
  refreshAllOverlays();
});

// ── Capture Preview as Video ──
// Records exactly what's on screen. The text overlay is screenshotted from the
// ACTUAL CSS-rendered DOM via html2canvas (not re-drawn with canvas text APIs).
// Color correction uses ctx.filter which IS the CSS filter engine. Zero translation.

async function captureTextOverlay(pair) {
  // Create a hidden container at FULL video resolution with the SAME CSS as the preview.
  // html2canvas screenshots this → pixel-perfect PNG of the text as CSS renders it.
  const w = pair.videoWidth || 432;
  const h = pair.videoHeight || 768;
  const caption = (pair.caption || '').trim();
  if (!caption) return null;

  const container = document.createElement('div');
  container.style.cssText = `
    position: fixed; left: -9999px; top: -9999px;
    width: ${w}px; height: ${h}px;
    overflow: hidden; background: transparent;
  `;

  const textDiv = document.createElement('div');
  textDiv.style.cssText = `
    position: absolute;
    left: ${pair.x}%;
    top: ${pair.y}%;
    transform: translate(-50%, -50%);
    max-width: 80%;
    text-align: center;
  `;

  const span = document.createElement('span');
  span.style.cssText = `
    font-family: '${fontFamilyName(pair.fontFile)}', sans-serif;
    font-weight: 700;
    font-size: ${pair.fontSize}px;
    color: white;
    -webkit-text-stroke: ${TEXT_STROKE_PX}px black;
    paint-order: stroke fill;
    line-height: 1.2;
    word-wrap: break-word;
    display: inline-block;
  `;
  span.textContent = caption;

  textDiv.appendChild(span);
  container.appendChild(textDiv);
  document.body.appendChild(container);

  // html2canvas screenshots the CSS-rendered text — EXACT match to preview
  const overlayCanvas = await html2canvas(container, {
    backgroundColor: null,  // transparent background
    width: w,
    height: h,
    scale: 1,
    logging: false,
  });

  document.body.removeChild(container);
  return overlayCanvas;  // returns a <canvas> element we can drawImage from
}

// Send html2canvas PNG + video path to server for ffmpeg overlay
async function burnOnServer(pair, index, batchId, overlayCanvas) {
  const overlayPng = overlayCanvas ? overlayCanvas.toDataURL('image/png') : null;
  const resp = await fetch('/api/burn-overlay', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      batchId,
      index,
      videoPath: pair.videoPath,
      overlayPng,
      colorCorrection: getColorCorrection(),
    }),
  });
  return resp.json();
}

// ── Burn All (server-side, parallel) ──
burnBtn.addEventListener('click', async () => {
  if (burning || !pairs.length) return;
  burning = true;
  burnBtn.disabled = true;
  burnBtn.textContent = 'Burning...';
  progressTrack.classList.add('active');
  progressLabel.classList.add('active');
  progressFill.style.width = '0%';
  progressFill.classList.remove('complete');

  const batchId = Date.now().toString(36);
  const total = pairs.length;
  let doneCount = 0;

  // Phase 1: Screenshot all text overlays in parallel (html2canvas)
  progressLabel.textContent = `Rendering ${total} text overlays...`;
  const textOverlays = await Promise.all(
    pairs.map(p => captureTextOverlay(p))
  );
  progressFill.style.width = '15%';

  // Phase 2: Send all to server in parallel — ffmpeg composites at full fps
  progressLabel.textContent = `Burning ${total} videos (server)...`;
  const burnPromises = pairs.map((pair, i) =>
    burnOnServer(pair, i, batchId, textOverlays[i]).then(result => {
      doneCount++;
      progressFill.style.width = (15 + Math.round((doneCount / total) * 85)) + '%';
      progressLabel.textContent = `Burned ${doneCount}/${total}...`;
      return result;
    }).catch(err => {
      doneCount++;
      return { index: i, ok: false, error: err.message };
    })
  );
  const results = await Promise.all(burnPromises);

  // Update cards with results
  results.forEach((result, i) => {
    const card = videoGrid.children[i];
    if (result.ok) {
      card.classList.add('burned');
      card.querySelector('.video-wrap').insertAdjacentHTML('beforeend',
        '<span class="burn-badge done">Burned</span>');
      card.querySelector('video').src = `/burned/${result.file}`;
      const tl = card.querySelector('.text-layer');
      if (tl) tl.style.display = 'none';
    } else {
      card.classList.add('error');
      card.querySelector('.video-wrap').insertAdjacentHTML('beforeend',
        `<span class="burn-badge fail" title="${esc(result.error || '')}">Error</span>`);
    }
  });

  const successCount = results.filter(r => r.ok).length;
  progressFill.style.width = '100%';
  progressFill.classList.add('complete');
  progressLabel.textContent = `Done! ${successCount}/${total} burned.`;
  burning = false;
  burnBtn.textContent = 'Burn All';
  loadBatches();
  burnBtn.disabled = false;

  if (successCount > 0) {
    exportBar.classList.add('active');
    exportInfo.textContent = `${successCount} burned`;
    const dl = () => {
      const a = document.createElement('a');
      a.href = `/api/burn-zip/${batchId}`;
      a.download = `burned_${batchId}.zip`;
      a.click();
    };
    dlBurnedBtn.onclick = dl;
    downloadSection.style.display = '';
    downloadAllBtn.onclick = dl;
  }
});

function esc(s) {
  const d = document.createElement('div');
  d.textContent = s || '';
  return d.innerHTML;
}
</script>

</body>
</html>
